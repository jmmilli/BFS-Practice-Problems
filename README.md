<h1>Breadth-First Search Practice Problems</h1>

<h2>Problem 1: Water Jug Problem</h2>
<h3>Description</h3>
This implementation solves the Water Jug Problem using BFS. It simulates two jugs of different capacities and performs actions such as filling, emptying, and pouring to find a sequence of steps to obtain a specific amount of water in either jug.
<br />

<h2>Features</h2>

- <b>State Representation </b>: Each state is represented as a pair of integers indicating the units of water in jug A and jug B.
- <b>Graph Generation </b>: Builds a graph of valid states and actions, determining neighbors for each state based on possible actions.

<h2>Usage</h2>

1. Compile the code.
2. Customize the main function to set the initial and target states for the water jugs.
3. Run the executable.

<h2>Example Output</h2>

![image](https://github.com/jmmilli/BFS-Practice-Problems/assets/118650262/7a584360-005d-47e0-b75d-9b8b12744cb9)

<h2>Problem 2: River Crossing Problem</h2>
<h3>Description</h3>
This implementation solves the River Crossing Problem using BFS. It models crossing a river with a wolf, a goat, a cabbage, and yourself, adhering to specific rules to ensure safe crossings ending with all entities being on the opposite side of the river. 
<br />

<h2>Features</h2>

- <b>State Representation </b>: Each state is represented using a bitset where each bit denotes the presence of the wolf, goat, cabbage, or yourself on either side of the river.
- <b>Valid Transitions </b>: Determines valid transitions between states ensuring the safety of the wolf, goat, and cabbage.
- <b>Graph Generation </b>: Builds a graph of valid states and actions based on safe crossings.

<h2>Usage</h2>

1. Compile the code.
2. Run the executable.

<h2>Example Output</h2>

![image](https://github.com/jmmilli/BFS-Practice-Problems/assets/118650262/b4f09c6f-0179-4503-a80b-faa1097d5e5e)


